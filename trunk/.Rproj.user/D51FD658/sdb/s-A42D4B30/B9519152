{
    "collab_server" : "",
    "contents" : "# 8.11.2016\n\n# General script to for community analysis of the sponges at Buoy 3, Wakatobi Marine Park, Indonesia.\n# Starting dataset is sponge counts per quadrats (square meter) from 2005 to 2016 (ongoing). Two years are missing\n# (2010, 2012). Sampling desing is as follows: vertical wall on a pristine (or at least not impacted) reef. Three sites,\n# A, B, C, replicate of each other. Sites do not recruit from each other. In each site, 5 quadrats.\n\n\n\nrequire(abind)\nrequire(plyr)\nrequire(ggplot2)\nrequire(reshape2)\nrequire(BiodiversityR)\nrequire(ggvegan)\n\ndataAllYears <- read.csv(\"//Staff/Home/SCIFAC/rovellal/DocumentsRedir/Data/Hoga/buoy3/spongeAbundanceQuadratsCleaned.csv\")\n\n# set flags\n\nflagRoutine <- \"average\" # can be either \"sum\" to add the 5 quadrats up, or any other string to take average and sd\n\n# load species list\n\nspecies <- read.csv(\"//Staff/Home/SCIFAC/rovellal/DocumentsRedir/Data/Hoga/buoy3/speciesKeyCleaned.csv\")\nspecies[species==\"\" | species==0] <- NA # drops empty spaces and zeroes\n\n# substitute description to blank fields in the species column\n\nspeciesOrDescription <- list()\n\nfor (i in 1:nrow(species)) {\n  if (is.na(species[,2][i])==T) {\n    speciesOrDescription[[i]] <- species[,3][i]\n  } else {\n    speciesOrDescription[[i]] <- species[,2][i]\n  }\n}\nspeciesOrDescription <- unlist(speciesOrDescription) #\n\n# extract general information about the dataset, to be called later \n\nyears <- levels(factor(substr(names(dataAllYears[-1]),2,3)))\nquadrats <- as.numeric(levels(factor(substr(names(dataAllYears), nchar(names(dataAllYears)), nchar(names(dataAllYears))))))\nquadrats <- quadrats[is.na(quadrats)==F]# number of quadrats per site\ndataColumns <- ncol(dataAllYears)-1 # number of quadrats in all sites in all years, effectively number of columns in the frame\nsites <- c(\"A\", \"B\", \"C\")\n\n\n# gets rid of zeros as characters in the datasets\n\nfor (i in 1:ncol(dataAllYears)) {\n  if (is.numeric(dataAllYears[,i])==T) {\n    dataAllYears[,i] <- dataAllYears[,i]\n  } else {\n    dataAllYears[,i] <- as.numeric(levels(dataAllYears[,i])[dataAllYears[,i]]) # this removes everything that won't fit as numeric\n  }\n}\n\ndataAllYears[is.na(dataAllYears)] <- 0 # turns NAs to zeroes\n\n# gets rid of the X in front of the column names\n\ncolnames(dataAllYears) <- c(names(dataAllYears)[1],\n                            substr(names(dataAllYears[,-1]), 2, nchar(names(dataAllYears[,-1]))))\n\n\n# this data frame is essentially the raw data and starting point for a series of plots and analysis coming up later in the script\n\n\n\n\n# *******************************************************************************************************************************\n\n# goal from now on is taking an average of the quadrats for site means\n\n# set indexing to operate across pools of columns, 5 in our case as we want to take averages for one site across all the quadrats\n\ndataAllYears <- dataAllYears[,-1] # run this!\n\nn <- 1:ncol(dataAllYears)\nind <- data.frame(matrix(c(n, rep(NA, 5 - ncol(dataAllYears)%%5)), byrow=F, nrow = 5))\nnonna <- sapply(ind, function(x) all(!is.na(x)))\nind <- ind[, nonna]\n\n# if statement to decide whether we want to add the quadrats or take their average, pointing to initial flag\n\nif (flagRoutine == \"sum\") {\n  electedFunction <- function(i)rowSums(dataAllYears[,i])\n} else {\n  electedFunction <- function(i) {\n    meanColumn <- rowMeans(dataAllYears[,i])\n    sdColumn <- apply(dataAllYears[,i], 1, sd)\n    cbind(meanColumn, sdColumn) \n  }\n}\n\nsitesFrame <- as.data.frame(do.call(cbind, lapply(ind, electedFunction))) \n\n# reorganize the dataframe with first the means and then the sd\n\nsitesFrame <- cbind(speciesOrDescription,\n                    sitesFrame[,grepl(\"mean\", names(sitesFrame))], \n                    sitesFrame[,grepl(\"sd\", names(sitesFrame))])\n\n# prepare vector with the column names ofor the site averages\n\nmyNames <- list()\n\nfor (i in 1:length(years)) {\n  myNames[[i]] <- paste(years[i], sites, sep = \"\")\n}\n\n\ncolnames(sitesFrame) <- c(\"Species\", paste(\"Mean\", unlist(myNames), sep = \"\"), paste(\"SD\", unlist(myNames), sep = \"\"))\n\n# what we have here is the data frame of the mean values per site, i.e. the average of all the quadrats has been taken\n\n\n# ********************************************************************************************************************\n\n# subset the mean abundances per site to the species accounting for 90% of the sponge numbers. \n# List of species may be slightly reduced than if performed on the single quadrats. Also MDS cares about differences between\n# sites in time, not quadrats, so this is actually legitimate if we do not pool species in undetermined (in which case it\n# does make a relevant difference if we consider quadrats or site means). The only point I'm not comfortable with is that\n# MDS+PCA operated on the means per instance kills the uncertainty across quadrats, which kind of belittles the point of having\n# replicates in the first place and also is not statistically sound, but then again the ordination on the quadrats makes no sense.\n# All in all it's about experimental design here.\n\nsortedMostAbundant <- list()\nfor (i in 1:((length(sitesFrame)+1)/2)) {\n  sortedMostAbundant[[i]] <- sitesFrame[order(sitesFrame[,i], decreasing = T),]\n  sortedMostAbundant[[i]] <- sortedMostAbundant[[i]][,c(1,i)]\n}\n\nsortedMostAbundant <- sortedMostAbundant[-1]\n\n# can decide that dominant species together account for 90% of the numbers\n\n\nchainsaw <- function(x, percent) {\n  # first it needs to calculate the sum of the numbers\n  sumOfNumbers <- sum(x[,2])\n  # then calculate n as in n = sumOfNumbers*domPerc / 100\n  n = sumOfNumbers*percent/100\n  # # then count how many elements of x[,2] are needed to go as big as n, where the count is z\n  v <- 0\n  z <- 0\n  for (i in 1:nrow(x)) {\n    if (v < n) {\n      v <- v + x[i,2]\n      z <- z + 1\n    } else {\n      v <- v\n      z <- z\n    }\n  }\n  # # finally subset the original frame x taking the first z counts, which should add up to the closest possible to\n  # # the chosen percentage\n  y <- x[1:z,]\n  return(y)\n  \n}\n\ndominantPerc <- lapply(sortedMostAbundant, chainsaw, 90)\n\nspeciesSet <- factor(levels(factor(unlist(lapply(dominantPerc, function(x) as.character(x[,1]))))))\n\n# now use it to subset the meanDataFrame, which must be entry for barchart\n\nsubsetData <- sitesFrame[sitesFrame[,1] %in% speciesSet,] \n\n# need to separate means from SD and melt them\n\nmeans <- subsetData[,1:((ncol(subsetData)+1)/2)]\nsd <- subsetData[c(1, (((ncol(subsetData)+1)/2)+1):ncol(subsetData))]\n  \nmeltMean <- melt(means, id.vars = \"Species\", variable.name = \"Instance\", value.name = \"Mean\")\nmeltSD <- melt(sd, id.vars = \"Species\", variable.name = \"Instance\", value.name = \"Mean\")\nmeltAll <- cbind(meltMean, meltSD[,ncol(meltSD)])\nmeltAll$Instance <- as.character(meltAll$Instance)\ncolnames(meltAll) <- c(names(meltAll)[-length(meltAll)], \"SD\")\nmeltAll$Year <- as.numeric(substr(meltAll$Instance, nchar(meltAll$Instance)-2, nchar(meltAll$Instance)-1))\nmeltAll$Site <- factor(substr(meltAll$Instance, nchar(meltAll$Instance), nchar(meltAll$Instance)))\n\n\n\n# 1. barchart for community composition. Rather uninformative with the classification at speceis level\n\nbarPlot <- ggplot(data = meltAll, aes(x = Year, y = Mean, fill = Species, group = Site))+\n  geom_bar(stat = \"identity\", position = \"stack\")+\n  scale_x_continuous(breaks = seq(5,16,1),\n                     labels = seq(5,16,1),\n                     limits = c(4,17))+\n  scale_y_continuous(limits = c(0,180),\n                     breaks = seq(0,180,20))+\n  #scale_fill_manual(values = getPalette(nOfColors))+\n  labs(y=expression(paste(Sponge~density~(n~m^2))))+\n  theme_bw()+\n  theme(panel.grid.minor = element_blank(), \n        panel.grid.major = element_blank())+\n  theme(plot.title = element_text(size=14, vjust=2))+\n  theme(axis.title.x = element_text(size=10,vjust=-0.5),\n        axis.title.y = element_text(size=10,vjust=0.5))+\n  theme(axis.text.x=element_text(size=10))+\n  theme(axis.text.y=element_text(size=10))+\n  #theme(legend.position=\"none\")+\n  facet_grid(.~Site)\nbarPlot\n\n\n# *****************************************************************************************************************\n\n\n# 2. Single species line plots (not visualising uncertainty)\n\nlinesPlot <- ggplot(data = meltAll, aes(x = Year, y = log(Mean+1), color = Species))+\n  geom_line(size = 1)+\n  geom_point()+\n  scale_x_continuous(breaks = seq(5,16,1),\n                     labels = seq(5,16,1),\n                     limits = c(4,17))+\n  scale_y_continuous(limits = c(0,5),\n                     breaks = seq(0,5,.5))+\n  #scale_fill_manual(values = getPalette(nOfColors))+\n  labs(y=expression(paste(log(Sponge~density~(n~m^2)))))+\n  theme_bw()+\n  theme(panel.grid.minor = element_blank(), \n        panel.grid.major = element_blank())+\n  theme(plot.title = element_text(size=14, vjust=2))+\n  theme(axis.title.x = element_text(size=10,vjust=-0.5),\n        axis.title.y = element_text(size=10,vjust=0.5))+\n  theme(axis.text.x=element_text(size=10))+\n  theme(axis.text.y=element_text(size=10))+\n  #theme(legend.position=\"none\")+\n  facet_grid(.~Site)\nlinesPlot\n\n\n\n\n# *****************************************************************************************************************\n\n# 3. Total species line plots with gaps for missing years\n\n# go back to the original data frame (dataAllYears) and transform it. \n# No species reduction, we do not care, we work on totals here\n\ntransDatatmp <- as.data.frame(t(dataAllYears))\ntransDatatmp <- transDatatmp[-1,] # gets rid of the line with the species IDs\n\n# need to turn it back to numeric because it all beccame factor in the meantime\n\ntransData <- as.data.frame(apply(transDatatmp, 2, function(x) as.numeric(as.character(x))))\n\nrownames(transData) <- rownames(transDatatmp)\n\n\ntransData$Total <- rowSums(transData)\n\n# need to separate years (my x variable) and quadrats\n\nquadratID <- rownames(transData)\ntransData$Year <- as.numeric(substr(quadratID, 1, 2))\ntransData$Site <- substr(quadratID, nchar(quadratID)-1, nchar(quadratID)-1)\ntransData$Quadrat <- substr(quadratID, nchar(quadratID), nchar(quadratID))  \ntransData$QuadratSite <- substr(quadratID, nchar(quadratID)-1, nchar(quadratID))\n\n# restrict to small data frame with only the total numbers and the quadrats IDs\n\nsmallFrame <- transData[,(ncol(transData)-4):ncol(transData)]\n\nlibrary(RColorBrewer)\npar(mar = c(0, 4, 0, 0))\ndisplay.brewer.all()\nnOfColorsQuad <- 5 # numer of quadrats\ngetPaletteQuad <- colorRampPalette(brewer.pal(5, \"Set1\"))\n\nquadratsFate <- ggplot(data = smallFrame, aes(x = Year, y = Total, group = QuadratSite, color = Quadrat))+\n  geom_line(aes(color = Quadrat), size = 1)+\n  geom_point()+\n  scale_color_manual(values = getPaletteQuad(nOfColorsQuad))+\n  scale_x_continuous(breaks = seq(5,16,1),\n                     labels = seq(5,16,1),\n                     limits = c(5,16))+\n  scale_y_continuous(limits = c(0,350),\n                     breaks = seq(0,350,50))+\n  labs(y=expression(paste(Sponge~density~(n~m^2))))+\n  theme_bw()+\n  theme(panel.grid.minor = element_blank(), \n        panel.grid.major = element_blank())+\n  theme(plot.title = element_text(size=14, vjust=2))+\n  theme(axis.title.x = element_text(size=10,vjust=-0.5),\n        axis.title.y = element_text(size=10,vjust=0.5))+\n  theme(axis.text.x=element_text(size=10, angle = 60, \n                                 hjust = 1, vjust = .9))+\n  theme(axis.text.y=element_text(size=10))+\n  facet_grid(. ~ Site, scales = \"free\")\nquadratsFate\n\n\n\n\n# ***************************************************************************************************************\n\n# 4. Growth of total numbers factorized by quadrats\n# Uses the same data frame of point 3. \n\nsmallFrame$TotalNextYear <- c(smallFrame$Total[(smallFrame$Year != 5)], \n                              rep(NA, nrow(smallFrame[smallFrame$Year == 5,])))\n\nspongesInTime <- ggplot(data = smallFrame, \n                        aes(x = Total, y = TotalNextYear, group = Quadrat))+\n  geom_point(aes(color = Quadrat))+\n  scale_color_manual(values = getPaletteQuad(nOfColorsQuad))+\n  scale_x_continuous(breaks = seq(0,350,50),\n                     labels = seq(0,350,50),\n                     limits = c(0,350))+\n  scale_y_continuous(limits = c(0,350),\n                     breaks = seq(0,350,50))+\n  labs(x=\"D(t)\", y=\"D(t+1)\")+\n  #geom_smooth(method = \"lm\")+\n  theme_bw()+\n  theme(panel.grid.minor = element_blank(), \n        panel.grid.major = element_blank())+\n  theme(plot.title = element_text(size=14, vjust=2))+\n  theme(axis.title.x = element_text(size=10,vjust=-0.5),\n        axis.title.y = element_text(size=10,vjust=0.5))+\n  theme(axis.text.x=element_text(size=10, vjust = .9))+\n  theme(axis.text.y=element_text(size=10))+\n  facet_grid(. ~ Site)\nspongesInTime\n\n\n\n\n# *******************************************************************************************************\n\n\n\n\n# Combination of nMDS and PCA with PERMANOVA or NPMANOVA, operating from Bray-Curtis matrix\n\nallMeans <- means[,-1]\n\nallMeansTrans <- log10(allMeans+1)\n\n\n# first we transpose (which is not necessary now but should become at some point I reckon)\n\ntransMatrix <- t(allMeansTrans)\n\ncolnames(transMatrix) <- speciesOrDescription[as.numeric(rownames(allMeans))]\n\n\n########################################################\n########################################################\n########################################################\n# EXPORT FOR PRIMER\n\nforPrimer <- t(allMeans)\ncolnames(forPrimer) <- speciesOrDescription[as.numeric(rownames(allMeans))]\n#write.csv(forPrimer, \"//Staff/Home/SCIFAC/rovellal/DocumentsRedir/Data/Hoga/buoy3/primerData.csv\")\n\n########################################################\n########################################################\n########################################################\n                                         \n\n\n\n# now structure is N as rows and species as columns. However, we osu old structure for computation (same ending point and I don't\n# have to recode it all up)\n\ngrandBC <- list()\n\nfor (i in 1:length(allMeansTrans)) { # home-made Bray-Curtis, makes little sense as there's vegdist in vegan doing it but it's solid (validated)\n  BC <- vector(mode = \"logical\", length = length(allMeansTrans))\n  for (j in 1:length(allMeansTrans)) {\n    reduced <- allMeansTrans[,c(i,j)]\n    BCpartial <- apply(reduced, 1, function(x) {\n      numBC <- 2*min(x[1], x[2])\n      denBC <- x[1]+x[2]\n      metrics <- c(numBC, denBC)\n    })\n    BC[j] <- rowSums(BCpartial)[1]/rowSums(BCpartial)[2]\n  }\n  grandBC[[i]] <- BC\n}\n\nsimMatrix <- abind(grandBC, along = 0)\ncolnames(simMatrix) <- names(allMeansTrans)\nrownames(simMatrix) <- names(simMatrix)\n\ndissMatrix <- 1-simMatrix # turn into dissimilarity\n\nfit <- isoMDS(dissMatrix, k = 2) # this is a ***NON-METRIC*** MDS plot based on Brey-Curtis dissimilarity.\n\ndistances <- as.data.frame(fit$points)\nrownames(distances) <- names(allMeansTrans)\ndistances$Names <- as.character(rownames(distances))\nfor (i in 1:nrow(distances)) {\n  distances$Year[i] <- paste(\"20\", substr(distances$Names[i], \n                                          (nchar(distances$Names[i])-2), \n                                          (nchar(distances$Names[i])-1)),\n                             sep = \"\")\n}\nfor (i in 1:nrow(distances)) {\n  distances$Site[i] <- substr(distances$Names[i], nchar(distances$Names[i]), nchar(distances$Names[i]))\n}\n\n# plot\n\n# validated against PRIMER\n\nMDSplot <- ggplot(data = distances, aes(x = V1, y = V2, group = Site, color = Year))+\n  geom_hline(yintercept = 0, linetype = \"dashed\")+\n  geom_vline(xintercept = 0, linetype = \"dashed\")+\n  geom_text(aes(label = Year, color = Year), size = 4.5, \n            fontface = \"bold\", vjust = 0, nudge_y = 0.02)+\n  guides(color=FALSE)+\n  geom_point(aes(shape = Site, color = Year), size = 2)+\n  scale_shape_manual(values = c(0,1,2))+\n  labs(x = \"MDS1\", y = \"MDS2\")+\n  #geom_path(size = 1)+\n  scale_x_continuous(limits = c(-.7,.7))+\n  scale_y_continuous(limits = c(-.7,.7))+\n  theme_bw()+\n  theme(\n    panel.grid.major.x = element_blank(),\n    panel.grid.minor.x = element_blank(),\n    panel.grid.major.y = element_blank(),\n    panel.grid.minor.y = element_blank())#+\n#facet_grid(.~Site)\nMDSplot\n\n# ggsave(\"//Staff/Home/SCIFAC/rovellal/DocumentsRedir/Wellington/words/latex/hogaExploratory/Pics/MDSplot.pdf\",\n#        MDSplot, useDingbats = T, width = 6, height = 5)\n\n\n# *********************************************************************************************************************************\n\n# CAP uses a dedicated package and starts from the species list\n\n# need to build a dummy frame apparently with data\n\ndummyMatrix <- as.data.frame(cbind(distances$Year, distances$Site)) # shouldn't this include the species somehow too?\ncolnames(dummyMatrix) <- c(\"Year\", \"Site\")\nrownames(dummyMatrix) <- rownames(transMatrix)\n\n# different formulas mean different ordinations, depending on the included variables\n\nCAPall <- capscale(transMatrix ~ Year + Site, dummyMatrix, distance = \"bray\", add = T)\nCAPTime <- capscale(transMatrix ~ Year, dummyMatrix, distance = \"bray\", add = T)\nCAPSpace <- capscale(transMatrix ~ Site, dummyMatrix, distance = \"bray\", add = T)\n\n# plots for different formulas\n\n# look like those obtained in PRIMER just a bit off\n\nplot(CAPall)\nplot(CAPTime)\nplot(CAPSpace)\n\n# all the below is just to get fancy with ggplot. Packages vegan and ggvegan will do all the job\n\ncomponents <- fortify(CAPall) # extract the coordinates from the cca objects calculated with capscale \ncomponents <- data.frame(lapply(components, function(x) {\n  x <- gsub(\"Year\", \"\", x)\n  x <- gsub(\"Site\", \"\", x)\n  x <- gsub(\"Mean\", \"\", x)\n  return(x)\n}))\ncomponents$Dim1 <- as.numeric(as.character(components$Dim1))\ncomponents$Dim2 <- as.numeric(as.character(components$Dim2))\ncomponents$Label <- gsub(\"spe\", \"\", components$Label)\n\n\n# plotting region\n\nplotData <- subset(components, components$Score != \"biplot\" & components$Score != \"constraints\" &\n                     components$Score != \"sites\")\nplotData$ColorKey <- c(rep(\"Species\", nrow(plotData[plotData$Score==\"species\",])), \n                       rep(\"Year\", 10), rep(\"Site\", 3)) # make this flexible on the iterations\n# fix levels\nplotData$ColorKey <- factor(plotData$ColorKey, levels = unique(plotData$ColorKey))\n\n\nCAPplot <- ggplot(data = plotData, aes(x = Dim1, y = Dim2, group = ColorKey))+\n  geom_hline(yintercept = 0, linetype = \"dashed\")+\n  geom_vline(xintercept = 0, linetype = \"dashed\")+\n  geom_segment(data = subset(plotData, plotData$Score == \"centroids\"),\n               aes(x = 0, xend = Dim1, y = 0, yend = Dim2), arrow = arrow(length = unit(1/2, 'picas')))+\n  geom_text(aes(label = Label, color = ColorKey, size = ColorKey))+\n  scale_color_manual(values = c(\"darkgrey\", \"red3\", \"cyan4\"))+\n  scale_size_discrete(range = c(4,8))+\n  theme_bw()+\n  labs(x = \"CAP1\", y = \"CAP2\")+\n  scale_x_continuous(limits = c(-.8,.8))+\n  scale_y_continuous(limits = c(-.8,.8))+\n  theme(\n    panel.grid.major.x = element_blank(),\n    panel.grid.minor.x = element_blank(),\n    panel.grid.major.y = element_blank(),\n    panel.grid.minor.y = element_blank())\nCAPplot\n\n# ggsave(\"//Staff/Home/SCIFAC/rovellal/DocumentsRedir/Wellington/words/latex/hogaExploratory/Pics/CAPplot.pdf\",\n#        CAPplot, useDingbats = T, width = 6.5, height = 5)\n\n\n# PERMANOVA\n\n# validated against PRIMER, same results, but I'm not sure it makes any sense. \n# Lack of replication (because we do not run it over the quadrats)\n\n# The community is different but we don't know why. Less conceptually, how do we ordinate a dataset with no\n# environmental covariates?\n\nadonis(transMatrix~Year + Site, data = dummyMatrix, permutations = 999, method = \"bray\")\n\n# yeah validated with PRIMER and all. I will actually have to give myself that I did a good job with more \n# luck than skill with this routine here, it's all mint.\n\n\n",
    "created" : 1478562198181.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "140|34|162|0|\n376|36|388|0|\n",
    "hash" : "2308107757",
    "id" : "B9519152",
    "lastKnownWriteTime" : 1478830005,
    "last_content_update" : 1478830005569,
    "path" : "//staff/Home/SCIFAC/rovellal/DocumentsRedir/rProjects/hoga/exploratoryHoga/trunk/completeBuoy3.R",
    "project_path" : "completeBuoy3.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}