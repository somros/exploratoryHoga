{
    "collab_server" : "",
    "contents" : "# MDS plot per site instead of per year\n\nrequire(abind)\nrequire(MASS)\nrequire(ggplot2)\n\nsetwd(\"//Staff/Home/SCIFAC/rovellal/DocumentsRedir/Data/Hoga/buoy3\")\nmyData <- read.csv(\"spongeAbundanceQuadrats.csv\")\n\n# turn to numeric immediately\n\nmyData <- myData[c(1:127),]\nmyData <- apply(myData, 2, as.numeric)\nmyData[is.na(myData)] <- 0 # turns NAs in 0, as necessary for Bray-Curtis\n\n\n# some steps to break down the frame in a list of frames, one per year per site.\n\nnOfQuadrats <- 5\n\n\n\n# TODO: introduce routine to cut data frames to the species accounting for 90% of the abundance. must be applied\n# to each quadrat and then all the species considered make the subset key for the entire data frame\n\n# we do it with apply. jk lol use a loop apply is slow af anyway\n\nperc <- 90\n\nspecies <- vector(\"list\", length = ncol(myData)-1)\n\nfor (k in 2:ncol(myData)) {\n  dataOrd <- myData[order(myData[,k], decreasing = T),]\n  # does the math: sum all the entries in one column to get the total\n  totNum <- sum(dataOrd[,k])\n  n <- totNum*perc/100\n  ntmp <- 0\n  spy <- 0\n  for (i in 1:nrow(dataOrd)) {\n    if (ntmp < n) {\n      ntmp <- ntmp + dataOrd[i,k]\n      spy <- i\n    } else {\n      ntmp <- ntmp\n      spy <- spy\n    }\n  }\n  species[[k]] <- dataOrd[c(1:spy),1]\n}\n\nspecies <- factor(levels(factor(unlist(species))))\n\n# now subset original data\n\nsubsetData <- myData[myData[,1] %in% species,] # there we go\n\n\n# if for whatever reason we want to use the entire set of species for the analysis, we can get rid of the above\n# section (this should become a flag). \n# the above routine may be better off if used on the means. That would rule out all the outliers from the\n# single quadrats. The number of species is however half the original amount.\n\n\ndataQuad <- subsetData[,-1] # remove species for convenience\n\n\n# create vector of indeces for consequent loop (breakage)\n\nindeces <- rep(1:30, each = 5)\n\ndataQuadN <- rbind(indeces, dataQuad)\n\n# split into list depending on the index\n\nnewList <- vector(mode = \"list\", length = length(indeces)/nOfQuadrats)\n\nfor (i in 1:length(newList)) {\n  subsetFrame <- dataQuadN[1,]==i\n  newList[[i]] <- dataQuadN[,subsetFrame]\n}\n\n\n# get rid of the index and make row means (sd later)\n\nnewListMeans <- lapply(newList, function(x) {\n  y <- x[-1,]\n  z <- rowMeans(y)\n  frame <- as.data.frame(z[1:nrow(dataQuad)])\n  colnames(frame) <- paste(\"Mean\", substr(names(x[1,])[1], 2,3), substr(names(x[1,])[1], 5, 5), sep = \"\")\n  return(frame)\n})\n\n\nallMeans <- as.data.frame(abind(newListMeans, along = 2))\n\n# transform in log(x+1). we can debate wether we want to have this done here or earlier. as a rule of thumb,\n# the earlier the better. Need to investigate the sensitivity to this of the MDS plot though, prepare 2 versions\n\n\nallMeansTrans <- log10(allMeans+1)\n\n# from now on as per in other script but using years instead\n\n\nyears <- levels(factor(unlist(lapply(names(allMeansTrans), function(x) {\n  substr(x, nchar(x)-2, nchar(x)-1)}))))\n\nyearsList <- vector(mode = \"list\", length = length(years))\n\n\nfor(i in years) {\n  yearsList[[match(i, years)]] <- allMeansTrans[,grepl(i, names(allMeansTrans))]\n}\n\n# now the similarity index must be calculated\n\nmatrixList <- list()\n\nfor (y in 1:length(yearsList)) {\n  \n  Y <- yearsList[[y]]\n  \n  grandBC <- list()\n  \n  for (i in 1:length(Y)) {\n    BC <- vector(mode = \"logical\", length = length(Y))\n    for (j in 1:length(Y)) {\n      reduced <- Y[,c(i,j)]\n      BCpartial <- apply(reduced, 1, function(x) {\n        numBC <- 2*min(x[1], x[2])\n        denBC <- x[1]+x[2]\n        metrics <- c(numBC, denBC)\n      })\n      BC[j] <- rowSums(BCpartial)[1]/rowSums(BCpartial)[2]\n    }\n    grandBC[[i]] <- BC\n  } # minchia che culo\n  \n  kekes <- abind(grandBC, along = 0)\n  colnames(kekes) <- names(Y)\n  rownames(kekes) <- names(kekes)\n  matrixList[[y]] <- kekes\n}\n\n\n# now MDS plots how the hell do they work\n\n# turn into bloody dissimilarity\n\ndissList <- lapply(matrixList, function(x) 1-x)\n\nfitList <- lapply(dissList, function(x) {\n  fit <- isoMDS(x, k = 2)\n  y <- fit$points[,1]\n  z <- fit$points[,2]\n  yzFrame <- data.frame(y,z)\n  yzFrame$Names <- names(x[1,])\n  return(yzFrame)\n}\n)\n\n\n# basically the other way round than the other scrpt. might make them methods to switch wiht flags\n\nallFrames <- as.data.frame(abind(fitList, along = 1))\nallFrames$y <- as.numeric(as.character(allFrames$y))\nallFrames$z <- as.numeric(as.character(allFrames$z))\nallFrames$Names <- as.character(allFrames$Names) # for substr\nallFrames$Year <- rep(years, each = 3)\n# add year for colour key\n\nallFrames$Site <- rep(NA, nrow(allFrames))\n\nfor (i in 1:nrow(allFrames)) {\n  allFrames$Site[i] <- substr(allFrames$Names[i], \n                                          (nchar(allFrames$Names[i])), \n                                          (nchar(allFrames$Names[i])))\n}\n\n# plot\n\nMDSplotSites <- ggplot(data = allFrames, aes(x = y, y = z, group = Year, color = Site))+\n  geom_text(aes(label = Site, color = Site))+\n  theme_bw()+\n  facet_wrap(~Year, nrow = 2)\nMDSplotSites\n\n\n# save this heresy in the latex folder\n\nggsave(\"//Staff/Home/SCIFAC/rovellal/DocumentsRedir/Wellington/words/latex/hogaExploratory/Pics/MDSSites.pdf\",\n       MDSplotSites, useDingbats = T) \n",
    "created" : 1476666622228.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2994623616",
    "id" : "9861F515",
    "lastKnownWriteTime" : 1476678150,
    "last_content_update" : 1476678150232,
    "path" : "//staff/Home/SCIFAC/rovellal/DocumentsRedir/rProjects/hoga/exploratoryHoga/trunk/MDSSites.R",
    "project_path" : "MDSSites.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}